<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PotholeWarrior – Web Map</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- MarkerCluster (for fast mobile-safe clustering) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <script
    src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"
  ></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* Simple “Folium-like” overlays */
    .map-overlay {
      background: rgba(255,255,255,0.92);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.15);
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .legend-row { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .swatch { width:14px; height:14px; border-radius:50%; border:1px solid rgba(0,0,0,0.25); }
    .logo-badge {
      display:flex; align-items:center; gap:10px;
    }
    .logo-badge img {
      width: 34px; height: 34px; border-radius: 8px;
      object-fit: cover; border: 1px solid rgba(0,0,0,0.15);
      background: #fff;
    }
    .logo-badge .title { font-weight: 700; }
    .logo-badge .sub { font-size: 12px; opacity: 0.8; margin-top: 2px; }
  </style>
</head>
<body>
<div id="map"></div>

<script>
  // ----------------------------
  // Helpers
  // ----------------------------
  // ----------------------------
// Probable pothole helpers (F9 parity)
// ----------------------------
const BURST_CLUSTER_RADIUS_M = 15.0;
const BURST_RECENT_DAYS = 7.0;
const CONF_HALF_LIFE_DAYS = 14.0;
const LOW_SPEED_MPS = 3.0;
const LOW_SPEED_PENALTY = 0.7;

function haversineMeters(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  return 2 * R * Math.asin(Math.sqrt(a));
}

function burstColor(score) {
  const s = Number(score) || 0;
  if (s >= 66) return "#e31116";
  if (s >= 33) return "#fe911d";
  return "#d7d807";
}

function sat(x, k) {
  x = Number(x) || 0;
  return 1 - Math.exp(-Math.max(0, x) / Math.max(1e-6, k));
}
  function pickFirst(obj, keys, fallback=null) {
    for (const k of keys) {
      if (obj && Object.prototype.hasOwnProperty.call(obj, k) && obj[k] !== null && obj[k] !== undefined) {
        return obj[k];
      }
    }
    return fallback;
  }

  // Color ramps (edit these once we confirm your exact property names + thresholds)
  function colorForSQI(sqi) {
    // Expect sqi 0..100 (higher = better). Adjust thresholds to match your Folium.
    if (sqi === null || sqi === undefined || isNaN(sqi)) return "#999999";
    if (sqi >= 90) return "#2ecc71";   // green
    if (sqi >= 75) return "#f1c40f";   // yellow
    if (sqi >= 60) return "#e67e22";   // orange
    return "#e74c3c";                  // red
  }

  function colorForEvent(props) {
    // Try to match your F9 contract:
    // - Tagged pothole -> RED
    // - Speed bump -> GREY
    // - Candidate pothole -> ORANGE (severity-scaled in size)
    const tagLabel = (pickFirst(props, ["tag_label", "tag", "label"], "") || "").toString().toLowerCase();
    const eventType = (pickFirst(props, ["event_type", "type"], "") || "").toString().toLowerCase();

    if (tagLabel.includes("pothole")) return "#ff0000";
    if (eventType === "speed_bump" || tagLabel.includes("speed")) return "#808080";
    if (eventType === "candidate_hit") return "#ff7a00";
    return "#1f78ff"; // fallback (blue)
  }

  function radiusForEvent(props) {
    // Use severity if present; otherwise a sensible default
    const sev = Number(pickFirst(props, ["severity", "sev", "score", "mag", "delta"], 1));
    if (isNaN(sev)) return 6;
    // Clamp + scale lightly (mobile-friendly)
    return Math.max(5, Math.min(14, 5 + sev * 2));
  }

  function colorForBurst(props) {
    // Bursts often represent “impacts” -> keep punchy
    // If you have "delta" or "mag", we can refine later.
    return "#ffffff"; // white marker like your current map; we can switch to red later if desired
  }

  function radiusForBurst(props) {
    const d = Number(pickFirst(props, ["delta", "mag", "impact", "severity"], 1));
    if (isNaN(d)) return 5;
    return Math.max(4, Math.min(12, 4 + d * 2));
  }

  function popupHtml(title, props) {
    const rows = Object.entries(props || {})
      .filter(([k,v]) => v !== null && v !== undefined && v !== "")
      .slice(0, 25) // keep popups light
      .map(([k,v]) => `<div><b>${k}</b>: ${String(v)}</div>`)
      .join("");
    return `<div style="min-width:220px"><div style="font-weight:700;margin-bottom:6px">${title}</div>${rows}</div>`;
  }

  // ----------------------------
  // Map init
  // ----------------------------
  const map = L.map("map", { preferCanvas: true }).setView([51.0, -0.1], 13);

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);

  const tonerLite = L.tileLayer("https://stamen-tiles.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png", {
    maxZoom: 20,
    attribution: "Map tiles by Stamen Design"
  });

  const baseLayers = {
    "OpenStreetMap": osm,
    "Toner Lite": tonerLite
  };

  // Overlay containers
  const segmentsLayer = L.layerGroup();
  const probableLayer = L.layerGroup();
  const eventsCluster = L.markerClusterGroup({
    chunkedLoading: true,
    chunkDelay: 25,
    maxClusterRadius: 55,
    spiderfyOnMaxZoom: true
  });
  const burstsCluster = L.markerClusterGroup({
    chunkedLoading: true,
    chunkDelay: 25,
    maxClusterRadius: 55,
    spiderfyOnMaxZoom: true
  });

  const overlays = {
  "Segments — Event SQI v2": segEvtLayer,
  "Segments — Physics SQI v2": segPhyLayer,
  "Bursts": burstsCluster,
  "Probable potholes (bursts, 15m)": probableLayer
};

  L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

  // ----------------------------
  // Load GeoJSON (relative files)
  // ----------------------------
  async function loadGeoJson(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${url}: ${res.status}`);
    return await res.json();
  }

  function addSegments(geo) {
    const gj = L.geoJSON(geo, {
      pointToLayer: (feature, latlng) => {
        const p = feature.properties || {};
        const sqi = Number(pickFirst(p, ["SQI", "sqi", "SQI_pred_v2", "SQI_pred", "sqi_pred", "score"], NaN));
        const col = colorForSQI(sqi);
        return L.circleMarker(latlng, {
          radius: 4,
          weight: 1,
          color: col,
          fillColor: col,
          fillOpacity: 0.75
        }).bindPopup(popupHtml("Segment", p));
      },
      style: (feature) => {
        // If segments are lines/polylines instead of points
        const p = (feature && feature.properties) || {};
        const sqi = Number(pickFirst(p, ["SQI", "sqi", "SQI_pred_v2", "SQI_pred", "sqi_pred", "score"], NaN));
        const col = colorForSQI(sqi);
        return { color: col, weight: 4, opacity: 0.8 };
      }
    });
    gj.addTo(segmentsLayer);
  }

  function addEvents(geo) {
    const gj = L.geoJSON(geo, {
      pointToLayer: (feature, latlng) => {
        const p = feature.properties || {};
        const col = colorForEvent(p);
        const r = radiusForEvent(p);
        const marker = L.circleMarker(latlng, {
          radius: r,
          weight: 1,
          color: col,
          fillColor: col,
          fillOpacity: 0.85
        }).bindPopup(popupHtml("Event", p));
        return marker;
      }
    });
    eventsCluster.addLayer(gj);
  }

  function addBursts(geo) {
    const gj = L.geoJSON(geo, {
      pointToLayer: (feature, latlng) => {
        const p = feature.properties || {};
        const col = colorForBurst(p);
        const r = radiusForBurst(p);
        const marker = L.circleMarker(latlng, {
          radius: r,
          weight: 1,
          color: "#000000",
          fillColor: col,
          fillOpacity: 0.95
        }).bindPopup(popupHtml("Burst", p));
        return marker;
      }
    });
    burstsCluster.addLayer(gj);
  }
  
  function addProbablePotholes(geo) {
  const bursts = (geo.features || []).map(f => {
    const p = f.properties || {};
    const coords = f.geometry.coordinates; // [lon, lat]
    return {
      lat: coords[1],
      lon: coords[0],
      score: Number(p.burst_score_v1) || 0,
      ts: p.obs_ts_utc ? new Date(p.obs_ts_utc) : null,
      drive: p.source_drive || "",
      speed: Number(p.speed_mps),
      trigger: Number(p.trigger_value) || Number(p.peak_accel_mag) || 0
    };
  });

  // F9: drop low-speed + high-accel (95th percentile accel proxy)
  const accelVals = bursts.map(b => b.trigger).filter(x => isFinite(x)).sort((a,b)=>a-b);
  const hiThr = accelVals.length ? accelVals[Math.floor(0.95 * (accelVals.length - 1))] : NaN;

  const filtered = bursts.filter(b => {
    const lowSpeed = !isFinite(b.speed) || b.speed < LOW_SPEED_MPS;
    if (!isFinite(hiThr)) return true;
    return !(lowSpeed && isFinite(b.trigger) && b.trigger >= hiThr);
  });

  // tmax for windows/decay
  let tmax = null;
  for (const b of filtered) {
    if (b.ts && (!tmax || b.ts > tmax)) tmax = b.ts;
  }
  if (!tmax) tmax = new Date(); // fail-open
  const recentCutoff = new Date(tmax.getTime() - BURST_RECENT_DAYS * 86400000);

  // Greedy clustering within 15m around running centroid
  const clusters = [];

  for (const b of filtered) {
    let assigned = false;

    for (const c of clusters) {
      const d = haversineMeters(b.lat, b.lon, c.lat, c.lon);
      if (d <= BURST_CLUSTER_RADIUS_M) {
        c.n += 1;
        c.lat = (c.lat * (c.n - 1) + b.lat) / c.n;
        c.lon = (c.lon * (c.n - 1) + b.lon) / c.n;

        c.scores.push(b.score);

        if (b.ts) {
          c.times.push(b.ts);
          c.days.add(b.ts.toDateString());
          if (b.ts >= recentCutoff) c.recentScores.push(b.score);
        }
        if (b.drive) c.drives.add(b.drive);

        const isLow = (!isFinite(b.speed) || b.speed < LOW_SPEED_MPS);
        if (isLow) c.lowSpeedHits += 1;

        assigned = true;
        break;
      }
    }

    if (!assigned) {
      const isLow = (!isFinite(b.speed) || b.speed < LOW_SPEED_MPS);
      clusters.push({
        lat: b.lat,
        lon: b.lon,
        n: 1,
        lowSpeedHits: isLow ? 1 : 0,
        scores: [b.score],
        recentScores: (b.ts && b.ts >= recentCutoff) ? [b.score] : [],
        times: b.ts ? [b.ts] : [],
        days: b.ts ? new Set([b.ts.toDateString()]) : new Set(),
        drives: b.drive ? new Set([b.drive]) : new Set()
      });
    }
  }

  // Render clusters as “Probable potholes”
  for (const c of clusters) {
    const nHits = c.n;
    const nDays = c.days.size;
    const meanScore = c.scores.reduce((a,b)=>a+b,0) / c.scores.length;

    const severity = c.recentScores.length ? Math.max(...c.recentScores) : Math.max(...c.scores);

    let ageDays = 999;
    if (c.times.length) {
      const last = new Date(Math.max(...c.times.map(t => t.getTime())));
      ageDays = (tmax.getTime() - last.getTime()) / 86400000;
    }

    const base =
      0.55 * sat(nHits, 6.0) +
      0.30 * sat(nDays, 2.0) +
      0.15 * Math.max(0, Math.min(1, meanScore / 100.0));

    const decay = Math.exp(-Math.log(2) * Math.max(0, ageDays) / CONF_HALF_LIFE_DAYS);

    let confidence = Math.max(0, Math.min(1, base * decay));

    const fracLow = c.lowSpeedHits / Math.max(1, nHits);
    confidence = Math.max(0, Math.min(1, confidence * (1 - LOW_SPEED_PENALTY * fracLow)));

    const radius = 4 + 10 * confidence;
    const opacity = 0.35 + 0.60 * confidence;
    const color = burstColor(severity);

    const popupHtml = `
      <b>PROBABLE POTHOLE (from bursts)</b><br>
      <b>confidence</b>: ${confidence.toFixed(2)}<br>
      <b>severity (recent max)</b>: ${severity.toFixed(1)}<br>
      <b>hits</b>: ${nHits}<br>
      <b>distinct days</b>: ${nDays}<br>
      <b>distinct drives</b>: ${c.drives.size}<br>
      <b>mean burst_score</b>: ${meanScore.toFixed(1)}<br>
      <b>age (days since last hit)</b>: ${ageDays.toFixed(1)}
    `;

    L.circleMarker([c.lat, c.lon], {
      radius,
      color,
      fillColor: color,
      fillOpacity: opacity,
      weight: confidence >= 0.55 ? 3 : 1
    }).bindPopup(popupHtml).addTo(probableLayer);
  }
}

  // Fit map to loaded data
  function fitToAll() {
    const groups = [];
    if (segmentsLayer.getLayers().length) groups.push(segmentsLayer);
    if (eventsCluster.getLayers().length) groups.push(eventsCluster);
    if (burstsCluster.getLayers().length) groups.push(burstsCluster);
    if (!groups.length) return;

    const fg = L.featureGroup(groups);
    try {
      map.fitBounds(fg.getBounds().pad(0.1));
    } catch (_) {}
  }

  // Load everything
  (async () => {
    try {
      const [seg, evt, bur] = await Promise.all([
        loadGeoJson("./segments.geojson"),
        loadGeoJson("./events.geojson"),
        loadGeoJson("./bursts.geojson")
      ]);

      addSegments(seg);
      addEvents(evt);
      addBursts(bur);
      addProbablePotholes(bur);

      // default-visible overlays (like Folium show=True)
      segmentsLayer.addTo(map);
      eventsCluster.addTo(map);
      burstsCluster.addTo(map);
      probableLayer.addTo(map);

      fitToAll();
    } catch (err) {
      alert(err.message || String(err));
      console.error(err);
    }
  })();

  // ----------------------------
  // Legend + Logo overlays
  // ----------------------------
  const legend = L.control({ position: "bottomleft" });
  legend.onAdd = function() {
    const div = L.DomUtil.create("div", "map-overlay");
    div.innerHTML = `
      <div style="font-weight:700;margin-bottom:6px">Legend</div>
      <div style="font-weight:600;margin-top:8px">Segments (SQI)</div>
      <div class="legend-row"><span class="swatch" style="background:${colorForSQI(95)}"></span> 90–100 (good)</div>
      <div class="legend-row"><span class="swatch" style="background:${colorForSQI(80)}"></span> 75–89</div>
      <div class="legend-row"><span class="swatch" style="background:${colorForSQI(65)}"></span> 60–74</div>
      <div class="legend-row"><span class="swatch" style="background:${colorForSQI(40)}"></span> &lt; 60 (bad)</div>

      <div style="font-weight:600;margin-top:10px">Events</div>
      <div class="legend-row"><span class="swatch" style="background:#ff0000"></span> Tagged pothole</div>
      <div class="legend-row"><span class="swatch" style="background:#808080"></span> Speed bump</div>
      <div class="legend-row"><span class="swatch" style="background:#ff7a00"></span> Candidate hit</div>

      <div style="font-weight:600;margin-top:10px">Bursts</div>
      <div class="legend-row"><span class="swatch" style="background:#ffffff"></span> Burst sample</div>

      <div style="font-size:12px;opacity:0.75;margin-top:10px">
        Tip: tap clusters to zoom in.
      </div>
    `;
    L.DomEvent.disableClickPropagation(div);
    return div;
  };
  legend.addTo(map);

  const logo = L.control({ position: "topright" });
  logo.onAdd = function() {
    const div = L.DomUtil.create("div", "map-overlay");
    div.innerHTML = `
      <div class="logo-badge">
        <!-- Optional: add a file named logo.png next to index.html and it will show -->
        <img src="./logo.png" onerror="this.style.display='none'" alt="Logo"/>
        <div>
          <div class="title">Pot Hole Warrior</div>
          <div class="sub">Dynamic Web Map</div>
        </div>
      </div>
    `;
    L.DomEvent.disableClickPropagation(div);
    return div;
  };
  logo.addTo(map);
</script>
</body>
</html>